<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[在CentOS7安裝新版Python]]></title>
      <url>/server/2022/08/04/008-centospy/</url>
      <content type="text"><![CDATA[前言紀錄一下怎麼在Centos7安裝新版的Python3並將python命令取代原本預安裝Python2.7。安裝流程先用yum安裝編譯python安裝包需要的軟體# yum update -y # yum -y groupinstall "Development tools" # yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel psmisc libffi-devel這邊我裝的是Python 3.9.13，下載for Linux的XZ compressed source tarball下載完之後解壓縮並進到python安裝檔目錄下。cd ~# wget https://www.python.org/ftp/python/3.9.13/Python-3.9.13.tar.xz# tar Jxvf Python-3.9.13.tar.xz# cd Python-3.9.13然後創建欲安裝的目錄之後生成安裝配置文件最後進行編譯與安裝。/* path = ~/Python-3.9.13 */# mkdir /usr/local/python# ./configure --prefix=/usr/local/python# make &amp;&amp; make install安裝完成後，接下來開始修改環境變數。首先把centos舊的python版本移走：# mv /usr/bin/python /usr/bin/python_old# mv /usr/bin/pip /usr/bin/pip_old建立新的軟連結# ln -s /usr/local/python/bin/python3.9 /usr/bin/python# ln -s /usr/local/python/bin/pip3.9 /usr/bin/pip下個指令檢查有沒有安裝成功# python -V&gt;&gt;&gt; Python 3.9.13# pip -V&gt;&gt;&gt; pip 22.0.4 from /usr/local/python/lib/python3.9/site-packages/pip (python 3.9)至此在Centos7安裝新版Python成功。]]></content>
      <categories>
        
          <category> Server </category>
        
      </categories>
      <tags>
        
          <tag> Centos </tag>
        
          <tag> Python </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CMAR: Accurate and Efficient Classification Based on Multiple Class-Association Rules]]></title>
      <url>/stady/2022/07/20/007-CMAR/</url>
      <content type="text"><![CDATA[作者  Wenmin Li  Jiawei Han  Jian Pei    摘要  傳統的關聯規則分類(CBA)在處理非結構化資料具有比較高的分類準確度及靈活性。但是在處理大型的資料庫時有問題，且因為基於Confidence來挑選分類規則導致出現過耦合的狀況。本篇研究提出一種新的關聯規則分類的方法CMAR其挖掘規則的方法採用FP-Growth，並採用Support、Confidence、相關度修剪規則，並進行加權分析建構分類器。實驗結果表示CMAR與其他分類演算法CBA、C4.5相比有更好的效率也有更好的分類準確度。方法生成FP-tree假設有一組資料循著FP-Growth的作法先定義Support threshold為2且本研究因為要將類別標籤也放入Tree中，所以有定義一confidence threshold為50%這邊指的Support是表示item在data set中出現的次數。且在生成樹的時候暫時不會用到confidence。依照Support threshold生成header table:            item      count                  $a_1$      4              $b_2$      3              $c_1$      3              $d_3$      3      根據header table去除不符合Support threshold的item生成的item set:            id      item      class                  1      $a_1, c_1$      A              2      $a_1, b_2, c_1$      B              3      $d_3$      A              4      $a_1, b_2, d_3$      C              5      $a_1, b_2, c_1, d_3$      C      最後生成出來的FP-tree從FP-tree提取規則這裡support表示這筆item包含該屬性值，confidence表示有包含這個屬性值的item且類別與規則相符的次數/有包含這個屬性值的item的總數X100%。依照生成的FP-tree來找pattern先從 d節點來看(以下為了簡化將各個item去掉下標):            item      count                  $a$      2              $b$      2              $d$      2      生成的規則：  $abd \to C, sup=2,conf=100\%$d節點完成之後要把原本d節點的類別標籤合併到父節點上，結果如圖:            item      count                  $a$      3              $b$      2              $c$      3      生成的規則：  $ac \to A, sup=1,conf=33\%$  $abc \to B, sup=1,conf=50\%$  $abc \to C, sup=1,conf=50\%$依此類推 b、a節點            item      count                  $a$      3              $b$      3      生成的規則：  $ab \to B, sup=1,conf=33\%$  $ab \to C, sup=2,conf=66\%$生成的規則：  $a \to A, sup=1,conf=25\%$  $a \to B, sup=1,conf=25\%$  $a \to C, sup=2,conf=50\%$最後由這棵樹生成的規則為下表：            ID      Rule      Support      Confidece                  1      $abd \to C$      2      100%              2      $ab \to C$      2      66%              3      $a \to C$      2      50%      Rule的排序有兩個規則$R_1$、$R_2$，如果:  $conf(R_1)&gt;conf(R_2)$  $conf(R_1)=conf(R_2)\&amp;sup(R_1)&gt;sup(R_2)$  $conf(R_1)=conf(R_2)\&amp;sup(R_1)=sup(R_2)$ 但$R_1$的屬性值比$R_2$少這樣就可以說 $R_1$is having higher rank than$R_2$另外可以說如果一個規則$R_1:P\to c$是$R_2:P^ˊ\to c^ˊ$的子集合，就可以說$R_1$是$R_2$的general rule。Pruning Rule透過剛剛的general rule我們在由規則生成CR-tree的時候進行第一步的Pruning。general rule如果有兩個規則$R_1$、$R_2$，若$R_1$是$R_2$的general rule且$R_1$的rank比$R_2$高就要將$R_2$ pruning掉。這部分是在建構CR-tree時完成。選擇正相關的規則假設有一條規則: (support = 30)實際表格：期望表格:$total_no$佔比$=\frac{30}{500} =\frac{3}{50}$            $R_1$      approved      rejected      total                  $job=yes$      $450 \times \frac{47}{50}$      $50 \times \frac{47}{50}$      $470$              $job=no$      $450 \times \frac{3}{50}$      $50 \times \frac{3}{50}$      $30$      會等於:套用公式:\[job=no \to class=rejected: X^2=\frac{(438-423)^2}{423}+\frac{(47-32)^2}{47}+\frac{(27-12)^2}{27}+\frac{(18-3)^2}{3}\approx88.4\]若$X^2$沒通過設定的significance level threshold該規則就該pruning掉。Selecting rules based on database coverage計算每個item被rule覆蓋且正確分類的次數:規則:            ID      Rule      Support      Confidece                  1      $abd \to C$      2      100%              2      $ab \to C$      2      66%              3      $a \to C$      2      50%      item set $\to R_1$            id      item      class      count                  1      $a, c$      A      0              2      $a, b, c$      B      0              3      $d$      A      0              4      $a, b, d$      C      1              5      $a, b, c, d$      C      1      item set $\to R_2$            id      item      class      count                  1      $a, c$      A      0              2      $a, b, c$      B      1              3      $d$      A      0              4      $a, b, d$      C      2              5      $a, b, c, d$      C      2      item set $\to R_3$            id      item      class      count                  1      $a, c$      A      1              2      $a, b, c$      B      2              3      $d$      A      0              4      $a, b, d$      C      3              5      $a, b, c, d$      C      3      這邊三條規則都有被select到。最終select到的規則就是我們拿來建構分類器的規則。分類分類結果分成三類  沒有matching rules  有一到多條matching rules，但只有對應到一個class。  有多條matching rules，有多個class，需要對選到的規則計算累計卡分值決定分為哪一類計算  及 得$R_1:job=no\to rejected$的$max^2\approx292.490226288$$R_1:job=no\to rejected$的$X^2\approx88.4$$R_1:job=no\to rejected$的$weightedX^2\approx0.3022$$R_2:education=university\to approved$的$max^2\approx495.84$$R_2:education=university\to approved$的$X^2\approx33.4256$$R_2:education=university\to approved$的$weightedX^2\approx0.06741$如果這邊有一個item符合這兩個rule的話這邊就要選擇$weightedX^2$較高的R_1來分類。結論與各方法比較的準確度:與各方法比較的記憶體使用量:與各方法比較的運行時間:]]></content>
      <categories>
        
          <category> stady </category>
        
      </categories>
      <tags>
        
          <tag> CBA </tag>
        
          <tag> Association rule </tag>
        
          <tag> data mining </tag>
        
          <tag> FP-growth </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Windows部署Laravel Sail]]></title>
      <url>/server/2022/07/18/006-laravelsail/</url>
      <content type="text"><![CDATA[前言  目前在研究各種架設Laravel的方法，經歷了Homestead、laradock最終還是走到了一開始最想使用的Sail。實際上使用起來跟感受到與laradock使用有明顯差別，原因是在於laradock使用的專案資料夾位於windows系統，而Laravel Sail是直接存放於WSL系統內，以筆者為例，開新的laravel專案在laradock開啟/歡迎頁面需要load 1秒的時間而在Sail中大概就只要幾十毫秒，以體感差非常多。剛好在laradock上的案件量不多趁新鮮趕緊換成Laravel Sail來使用，以下將帶來在Windows 11 上部屬Laravel Sail的過程。關於laradock在windows上的檔案IO其實是有解的，但我覺得有點麻煩就沒用了。部屬流程  Sail還是基於Docker的做法，所以依然要安裝Docker，在windows上安裝Docker可以看我上一篇文章有介紹。安裝Ubuntu  打開Microsoft Store搜尋Ubuntu我這邊安裝的是20.4.4版安裝好後要確認WSL版本是不是2，Windows11的話預設就是WSL2了，好了之後要去Dokcer Desktop設定Resources&gt;WSL intergration選取安裝的Linux系統。好了之後開啟Windows終端機(沒有的話一樣去MSstore裝一裝就好了)。會自動新增剛剛安裝的ubuntu於你的新增標籤內。開啟Ubuntu後因為如果是舊專案會需要用到composer所以要先安裝PHP，依自己的需求安裝PHP版本及擴展。#更新aptsudo apt update &amp;&amp; sudo apt install php#添加安裝包sudo apt install software-properties-commonsudo add-apt-repository ppa:ondrej/php#安裝php 8.1sudo apt install php8.1#安裝php拓展sudo apt install php8.1-gd php8.1-xml php8.1-soap php8.1-mbstring php8.1-mysql如果有切換php版本的需求可以使用sudo update-alternatives --config php 再來安裝composer#下載composer安裝檔wget -O composer-setup.php https://getcomposer.org/installer#安裝到/usr/local/bin目錄下sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer#查看是否安裝成功composer -v安裝Nginx-proxy-manager  為了方便設定自己想要的域名，首先進入WSL終端機下，到家目錄新建一個proxy-manager資料夾。cd ~ &amp;&amp; mkdir proxy-manager進入proxy-manager文件夾並創建docker-compose.ymlcd proxy-manager &amp;&amp; vim docker-compose.yml於docker-composer.yml文件貼上version: "3"services:  app:    image: 'jc21/nginx-proxy-manager:latest'    restart: always    ports:      # Public HTTP Port:      - '80:80'      # Public HTTPS Port:      - '443:443'      # Admin Web Port:      - '81:81'    environment:      # These are the settings to access your db      DB_SQLITE_FILE: "/data/database.sqlite"      # Uncomment this if IPv6 is not enabled on your host      DISABLE_IPV6: 'true'    volumes:      - ./data:/data      - ./letsencrypt:/etc/letsencrypt然後啟動containerdocker-composer up -d好了之後去瀏覽器進入localhost:81就可以進到管理員頁面Email address: admin@example.comPassword: changeme就可以設定你的帳號。設定完成後: 設定Laravel Sail  分成兩個部分：在舊的專案上使用Sail、新增新的專案使用Sail這邊先講如果在舊專案上使用Sail。首先先進入Ubuntu然後在你的專案底下，使用 composer 安裝 Laravel Sail。composer require laravel/sail --dev接著使用 artisan 指令產出 docker-compose.yml。php artisan sail:install可以選擇想要使用的服務。 Which services would you like to install? [mysql]:  [0] mysql  [1] pgsql  [2] mariadb  [3] redis  [4] memcached  [5] meilisearch  [6] minio  [7] mailhog  [8] selenium &gt; 0,3,7Sail scaffolding installed successfully.之後就可以使用 docker 來建置開發環境了。./vendor/bin/sail up如果不想打那麼多字的話可以在 .bashrc 或是 .zshrc 中設定 alias（別名）。alias sail='bash vendor/bin/sail'這樣啟動開發環境只需要輸入 sail 就好，啟動之後如果想終止，可以使用 Ctrl + C 終止容器。sail up如果想要在背景執行，可以加上 -d 選項，即 Docker 原始提供的參數 -d, --detach。sail up -d終止所有 Laravel Sail 所有服務容器。sail stop想要終止在背景執行的 Laravel Sail 並刪除所有服務容器的話。sail down設置域名編輯你專案的.env新增APP_PORT=48080FORWARD_DB_PORT=43306FORWARD_REDIS_PORT=46379FORWARD_MEILISEARCH_PORT=47700FORWARD_MAILHOG_PORT=41025FORWARD_MAILHOG_DASHBOARD_PORT=48025之後到你本機修改host新增域名127.0.0.1 project.tset之後瀏覽器開啟localhost:81點選Hosts -&gt; Proxy Hosts -&gt; Add Proxy Hosts輸入你定義的域名，並在Forward Hostname/IP填入host.docker.internal，port填入48080後save。之後直接訪問project.tset就可以看到你的專案了。之後新增新的專案除了.env裡的port要改，docker-compose.yml 裡面的vite port也要改(如果laravel版本&gt;9)。新增專案curl -s https://laravel.build/project1 | bash設定方法跟上面一樣。我的 docker-compose.yml加裝了phpmyadmin# For more information: https://laravel.com/docs/sailversion: '3'services:    laravel.test:        build:            context: ./vendor/laravel/sail/runtimes/8.1            dockerfile: Dockerfile            args:                WWWGROUP: '${WWWGROUP}'        image: sail-8.1/app        extra_hosts:            - 'host.docker.internal:host-gateway'        ports:            - '${APP_PORT:-80}:80'            - '${VITE_PORT:-5173}:${VITE_PORT:-5173}'        environment:            WWWUSER: '${WWWUSER}'            LARAVEL_SAIL: 1            XDEBUG_MODE: '${SAIL_XDEBUG_MODE:-off}'            XDEBUG_CONFIG: '${SAIL_XDEBUG_CONFIG:-client_host=host.docker.internal}'        volumes:            - '.:/var/www/html'        networks:            - sail        depends_on:            - mysql            - redis            - meilisearch            - selenium    mysql:        image: 'mysql/mysql-server:8.0'        ports:            - '${FORWARD_DB_PORT:-3306}:3306'        environment:            MYSQL_ROOT_PASSWORD: '${DB_PASSWORD}'            MYSQL_ROOT_HOST: "%"            MYSQL_DATABASE: '${DB_DATABASE}'            MYSQL_USER: '${DB_USERNAME}'            MYSQL_PASSWORD: '${DB_PASSWORD}'            MYSQL_ALLOW_EMPTY_PASSWORD: 1        volumes:            - 'sail-mysql:/var/lib/mysql'            - './vendor/laravel/sail/database/mysql/create-testing-database.sh:/docker-entrypoint-initdb.d/10-create-testing-database.sh'        networks:            - sail        healthcheck:            test: ["CMD", "mysqladmin", "ping", "-p${DB_PASSWORD}"]            retries: 3            timeout: 5s    redis:        image: 'redis:alpine'        ports:            - '${FORWARD_REDIS_PORT:-6379}:6379'        volumes:            - 'sail-redis:/data'        networks:            - sail        healthcheck:            test: ["CMD", "redis-cli", "ping"]            retries: 3            timeout: 5s    meilisearch:        image: 'getmeili/meilisearch:latest'        ports:            - '${FORWARD_MEILISEARCH_PORT:-7700}:7700'        volumes:            - 'sail-meilisearch:/meili_data'        networks:            - sail        healthcheck:            test: ["CMD", "wget", "--no-verbose", "--spider",  "http://localhost:7700/health"]            retries: 3            timeout: 5s    mailhog:        image: 'mailhog/mailhog:latest'        ports:            - '${FORWARD_MAILHOG_PORT:-1025}:1025'            - '${FORWARD_MAILHOG_DASHBOARD_PORT:-8025}:8025'        networks:            - sail    selenium:        image: 'selenium/standalone-chrome'        volumes:            - '/dev/shm:/dev/shm'        networks:            - sail    phpmyadmin:        image: 'phpmyadmin:latest'        ports:          - 8080:80        environment:          MYSQL_ROOT_PASSWORD: '${DB_PASSWORD}'          PMA_HOST: mysql          PMA_USER: '${DB_USERNAME}'          PMA_PASSWORD: '${DB_PASSWORD}'        links:          - "mysql:db"        depends_on:          - mysql        networks:          - sailnetworks:    sail:        driver: bridgevolumes:    sail-mysql:        driver: local    sail-redis:        driver: local    sail-meilisearch:        driver: local可以直接照用，如果想要對建立的容器進行調整的話，可以將 sail 的 docker-compose.yml 產出來。php artisan sail:publish此時專案底下就會多一個 docker 資料夾，底下會放置建置容器用的 Dockerfile 還有 php.ini 等設定檔案。$ tree dockerdocker├── 7.4│   ├── Dockerfile│   ├── php.ini│   ├── start-container│   └── supervisord.conf├── 8.0│   ├── Dockerfile│   ├── php.ini│   ├── start-container│   └── supervisord.conf└── 8.1    ├── Dockerfile    ├── php.ini    ├── start-container    └── supervisord.conf3 directories, 12 filesdocker-compse.yml 中的 context 也會更動，從 ./vendor/laravel/sail/runtimes/8.1 會從改成 ./docker/81。build:    context: ./docker/8.1    dockerfile: Dockerfile更動後，需要重新建立容器，這裡可以使用 build 的指令。sail build --no-cache用Sailx來開發#原先使用php artisan migrate#改成sail artisan migrate除此之外還有整合 php 指令。sail php --versionsail php script.php其他東西邏輯差不多，可以參考官網的Sail文檔。參考資料  用 Laravel Sail 來建置 Laravel 開發環境  Laravel SAil  proxy-manager]]></content>
      <categories>
        
          <category> Server </category>
        
      </categories>
      <tags>
        
          <tag> Laravel </tag>
        
          <tag> Docker </tag>
        
          <tag> Sail </tag>
        
          <tag> WSL2 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Windows部署Laradock]]></title>
      <url>/server/2022/07/07/005-laradock/</url>
      <content type="text"><![CDATA[前言以往在Windows系統上建立 PHP 相關專案大多都使用 XAMPP 等集成軟體，或是在 Server 主機上安裝 LAMP/LNMP，不相同的平台建置各有各自的作法，在開發不同專案時如果有切換 PHP 版本的需求，跟依賴與Virtualbox導致I/O瓶頸的Vagrant相比使用 Laradock 除了I/O速度的問題外套件的未來維護也更勝一籌，所以以下我將記錄我在Windows10上面架設laradock的過程。LaradockLaradock 是基於 Docker 的一個快速建立 Laravel/PHP 的開發環境工具，Docker 則是在各作業系統上先做出一個共通的平台，將應用程式獨立於Container 當中，省去搭建作業系統的成本。Dokcer Desktop 在Windows中依賴WSL什麼是 WSL？WSL 2 是「Windows 子系統 Linux 版」架構的新版本，可讓 Windows 子系統 Linux 版在 Windows 上執行 ELF64 Linux 二進位檔。 其主要目標是增加檔案系統效能，以及新增完整的系統呼叫相容性。與Virtualbox虛擬機相比有更接近系統底層的效能及相容性。安裝步驟系統需求  CPU為64位元  有4G以上的RAM  BIOS的虛擬化技術已啟用Windows 環境官方說明：https://docs.docker.com/desktop/windows/wsl/用管理員身分執行 Windows 終端機 、 cmd 、 powershell，執行以下命令啟用 Windows 子系統 Linux 版dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart啟用虛擬機器功能dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart  Docker先下載Windows版本的Docker Desktop Installer下載 Linux 核心更新套件並安裝WSL2 Linux 核心更新套件 (適用於 x64 電腦)完成後重新開機後Docker已可正常運作設定Laradock建立一個資料夾存放laradockgit clone https://github.com/laradock/laradock.git laradock並新增 www 於同層資料夾。 並在www資料夾新增 case-1 、 case-2 兩個資料夾。結構如下├─Laradock└─www    ├─case-1    └─case-2進入Laradock資料夾 並且複製已經準備好的範例檔 env.examplecd laradockcp .env.example .env打開.env文件進行編輯APP_CODE_PATH_HOST=../wwwAPP_CODE_PATH_CONTAINER=/var/www上面主要是修改專案存放路徑，其他如PHP、MYSQL、PPMA、Nginx等設定可以依自己的需求在.env修改。設定Nginx到 /laradock/nginx/sites資料夾複製laravel.conf.example為primary.conf，接下來編輯primary.conf。# 原本的root /var/www/laravel/public# 修改為(因為www 要放各項專案，且laravel任何request導入進來都需要走public目錄)root /var/www/case-1/public# 原本的server_name laravel.test;# 修改為 待會會建立兩個Laravel傳案做示範這邊以project1.test當作第一個傳案server_name project1.test;# server_name : 網域# root ：對應的檔案路徑# 所以這兩個網域只要後面的port號打對一樣都能進入相對應的檔案路徑 再來新增case-2的config，為節省時間，全部的內容如下。#server {#    listen 80;#    server_name laravel.com.co;#    return 301 https://laravel.com.co$request_uri;#}server {    listen 80;    listen [::]:80;    # For https    # listen 443 ssl;    # listen [::]:443 ssl ipv6only=on;    # ssl_certificate /etc/nginx/ssl/default.crt;    # ssl_certificate_key /etc/nginx/ssl/default.key;    server_name case-1.test;    root /var/www/case-1/public;    index index.php index.html index.htm;    location / {         try_files $uri $uri/ /index.php$is_args$args;    }    location ~ \\.php$ {        try_files $uri /index.php =404;        fastcgi_pass php-upstream;        fastcgi_index index.php;        fastcgi_buffers 16 16k;        fastcgi_buffer_size 32k;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        #fixes timeouts        fastcgi_read_timeout 600;        include fastcgi_params;    }    location ~ /\\.ht {        deny all;    }    location /.well-known/acme-challenge/ {        root /var/www/letsencrypt/;        log_not_found off;    }    error_log /var/log/nginx/laravel_error.log;    access_log /var/log/nginx/laravel_access.log;}server {    listen 80;    listen [::]:80;    # For https    # listen 443 ssl;    # listen [::]:443 ssl ipv6only=on;    # ssl_certificate /etc/nginx/ssl/default.crt;    # ssl_certificate_key /etc/nginx/ssl/default.key;    server_name case-2.test;    root /var/www/case-2/public;    index index.php index.html index.htm;    location / {         try_files $uri $uri/ /index.php$is_args$args;    }    location ~ \\.php$ {        try_files $uri /index.php =404;        fastcgi_pass php-upstream;        fastcgi_index index.php;        fastcgi_buffers 16 16k;        fastcgi_buffer_size 32k;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        #fixes timeouts        fastcgi_read_timeout 600;        include fastcgi_params;    }    location ~ /\\.ht {        deny all;    }    location /.well-known/acme-challenge/ {        root /var/www/letsencrypt/;        log_not_found off;    }    error_log /var/log/nginx/laravel_error.log;    access_log /var/log/nginx/laravel_access.log;}Build Docker Image to Containerdocker-compose up -d nginx mysql phpmyadmin開啟工作區域的bash#****進入Container 內建立專案，可呼叫artisan、composer 相關指令**** docker-compose exec workspace bash# 實際上在www資料夾位置，此時先使用Composer 安裝Laravel(項目各自為case-1、case-2)composer create-project laravel/laravel --prefer-dist case-1composer create-project laravel/laravel --prefer-dist case-2#離開 Containerexit選擇任一case專案的.env做測試連線mysql先去phpMyAdmin新建一個case-1的資料庫。接著複製.env.example為.env並修改以下內容。# 因為實際執行時是在docker容器內，容器內的mysql的port目前是3306# 外面連線時是依據剛剛MYSQL_PORT的設定DB_CONNECTION=mysqlDB_HOST=mysqlDB_PORT=3306DB_DATABASE=case-1DB_USERNAME=root進行migrate測試是否有連上資料庫。####當前目錄 : /laradockdocker-compose exec workspace bashcd case-1php artisan migrate如果正常應該可以看到手動設定網址與 IP 對應的 hosts 做測試在C:\Windows\System32\drivers\etc開啟host檔案並新增127.0.0.1 case-1.test127.0.0.1 case-2.test開啟專案網址。直接在瀏覽器的網址列輸入127.0.0.1 case-1.test127.0.0.1 case-2.test可以看到laravel的歡迎畫面就代表設定成功了。phpMyAdmin http://127.0.0.1:8081/root 預設值   帳號: root密碼: rootuser 預設值帳號: PMA_USER=default密碼: PMA_PASSWORD=secret參考資料  一步步教您使用 Laradock 快速打造Laravel/PHP 環境  laradock  laradock 笔记]]></content>
      <categories>
        
          <category> Server </category>
        
      </categories>
      <tags>
        
          <tag> Laravel </tag>
        
          <tag> Docker </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Windows部署Laravel Homestead]]></title>
      <url>/server/2022/07/07/004-lavarel-homestead/</url>
      <content type="text"><![CDATA[前言以前寫的PHP專案都是用CodeIgniter當框架來開發，但最近公司要轉用Laravel來當之後的開發框架，因為之前虛擬環境都是用Vagrant來架設，估狗windows 開發 laravel裡面找到lavavel.tw裡面就有答案了。殊不知年輕人就是年輕人想得太少了…原來lavavel.tw這個官方文檔對應的laravel版本是5.3。看了一下公司專案的版本…8.x!會這樣講，是因為我又是裝完之後才發現的，因為要Build好開發環境才能看專案阿XD都怪我沒仔細看專案內容QQ，但裝了都裝了，我還是要記錄一下Laravel Homestead的架設過程。VagrantVagrant是一個用Vagrantfile來設定的虛擬環境軟體，要使用你要先安裝：  Vagrant  VirtualBoxVagrant跟VirtualBox的版本有對應關係，需要各自安裝對的版本才能正常運行！具體上的教學網路有很多且不是本文重點，我就不贅述了。Laravel Homestead  Laravel Homestead 是一個官方預載的 Vagrant box，提供一個美好的開發環境，不需要在本機電腦安裝 PHP、HHVM、網頁伺服器或任何伺服器軟體。不用擔心搞亂你的系統！Vagrant box 可以搞定一切。如果有什麼地方搞爛掉了，還可以在幾分鐘內快速地砍掉並重建虛擬機器！安裝 Homestead Vagrant Box當 VirtualBox / VMware 以及 Vagrant 安裝完成後，可以在終端機執行下列指令將 laravel/homestead 這個 box 安裝進你的 Vagrant 程式中。下載 box 會花一點時間，時間長短將依據你的網路速度決定：vagrant box add laravel/homestead安裝 Homestead可以簡單地透過複製(clone)儲存庫的方式來安裝 Homestead。建議可將儲存庫複製至你的「home」目錄中的 Homestead 資料夾，如此一來 Homestead box 將能提供主機服務給你所有的 Laravel 專案：git clone https://github.com/laravel/homestead.git Homestead複製完 Homestead 儲存庫，即可在 Homestead 目錄中執行 bash init.sh 指令來建立 Homestead.yaml 設定檔。 Homestead.yaml 檔案將會被放置在homestead目錄中：./init.bat設定 Homestead設定提供者在 /homestead/Homestead.yaml 檔案中的 provider 是用來設定想要使用哪一個 Vagrant 提供者，像是：virtualbox、vmware_fusion、vmware_workstation 或 parallels。這邊我們要填寫:provider: virtualbox設定共享目錄在 Homestead.yaml 檔案的 folders 屬性裡列出所有想與 Homestead 環境共享的目錄。這些目錄中的檔案若有更動，它們將會同步更動在你的本機電腦與 Homestead 環境。可以將多個共享目錄都設定於此：folders:    - map: C:\Code      to: /home/vagrant/Code設定 Nginx 網站sites 屬性幫助你可以輕易的指定「網域」對應至 homestead 環境中的目錄。在 Homestead.yaml 檔案中已包含一個網站設定範例。同樣的，你可以增加數個網站到 Homestead 環境中。Homestead 可以為每個你正在開發中的 Laravel 專案提供方便的虛擬化環境：sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public在配置 Homestead box 之後，若有更改 sites 屬性，你應該重新執行配置指令 vagrant reload --provision 來更新虛擬機裡的 Nginx 設定。Hosts 檔案你必須為 Nginx 網站在你機器中的 hosts 檔案增加「網域」。hosts 檔案會將你對 Homestead 網站的請求重導至 Homestead 機器。在 Mac 或 Linux 上，在 Windows 上，則存放於 C:\Windows\System32\drivers\etc\hosts。你增加至該檔案的內容看起來會像這樣：192.168.10.10  homestead.app務必確認 IP 位置與你的 Homestead.yaml 檔案中設定相同。一旦將網域設定在 hosts 檔案之後，你就可以透過網頁瀏覽器造訪網站！http://homestead.app啟動 Vagrant Box當你編輯完 Homestead.yaml後，開啟終端機，進入 Homestead 目錄，並執行 vagrant up 指令。Vagrant 就會自將虛擬主機啟動並自動設定共享目錄和 Nginx 網站。如果要移除虛擬機器，可以使用 vagrant destroy --force 指令。透過 SSH 連接你可以在終端機裡進入你的 Homestead 目錄，並執行 vagrant ssh 指令藉此以 SSH 連上你的虛擬主機。參考資料laravel.tw/docs/5.3/homestead]]></content>
      <categories>
        
          <category> Server </category>
        
      </categories>
      <tags>
        
          <tag> Laravel </tag>
        
          <tag> Vagrant </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[文章預覽顯示設定]]></title>
      <url>/%E5%89%8D%E7%AB%AF/2022/07/07/003-page/</url>
      <content type="text"><![CDATA[前言看了一下自己的網誌之後覺得哪邊怪怪的，原來是因為在文章列表中顯示出來的預覽範圍的問題啊！趕緊查一下資料，將找到的方法紀錄一下。實作通過分隔符的方式.需要先在_config.yml中配置分隔符excerpt_separator:  '&lt;!-- more --&gt;'然後就可以在正文中通過插入&lt;!-- more --&gt;來將以上的內容標記為文章摘要.參考資料  Jekyll文章列表摘要設置]]></content>
      <categories>
        
          <category> 前端 </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[完善網誌：留言區、版權資訊、訪問人數]]></title>
      <url>/%E5%89%8D%E7%AB%AF/2022/07/05/002-complete/</url>
      <content type="text"><![CDATA[前言續昨天 建置jekyll+Github Page完成基本設定後，我又參考Ank’s Blog、辛西亞的技能樹等大大的網誌內的教學文，新增一些功能到我的網誌內，讓功能更完善一些。新增版權資料參考了辛西亞大大的版權訊息配置，我這邊做了一些更改，簡單來說就是用jekyll內的UI把自訂的版權信息放到文章底部。開啟版權訊息功能到 /_config_yml 找到 post_copyright 把 false 改成 true，再把版權資訊license、license_url填進去。post_copyright:  enable: true  license: CC BY-NC-SA 4.0  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en顯示在頁面中的版權資訊則是要到_data/languages/default.yml裡面修改，不過因為我在/_config_yml裡面設定的預設語言是zh-tw所以我要找到_data/languages/zh-tw.yml去修改。我覺得原本辛西亞大大寫的內容已經夠好了再去改就有點顯得畫蛇添足，所以這邊直接使用她的範例。 copyright:   author: 本文作者   link: 本文連結   license_title: 版權聲明   license_content: '除非另有標注，部落格中所有文章，均採用     &lt;a href="%s" rel="external nofollow" target="_blank"&gt;%s&lt;/a&gt; 許可協議。     轉載請標明作者、連結與出處！'這樣版權訊息就會出現在文章底部囉!版權訊息關閉選項因為辛西亞大大的聲明裡面寫到：「除非另有標注…」，既然寫說另有標注代表可能會有不加訊息的狀況，因此可以加個開關可以決定是否放置版權訊息：      修改 HTLM 檔 先回到 _includes/_macro/post.html 中找到剛剛引入 post-copyright.html 的位置，並在 include 外加上條件式。 在這邊設定了一個名為 copyright 的 flag，且僅希望在 copyright 設定為 false 時才會隱藏該區域；若未設定或設定為 ture 時，則正常顯示該區，因此我必須明確寫出它的條件式：     + {％ if page.copyright != false ％}     {％ include _macro/post-copyright.html ％}    + {％ endif ％}            ymal 設定 搞定後，當你某篇文章不放置版權訊息時，就在文章上方的 yaml 區，設定的 copyright 的 flag：     --- title: "完善網誌：留言區、版權資訊、訪問人數" date: 2022-07-05 + copyright: false ---      複製網頁文字時，加上網站的作者與網址另外一個是常見的在複製文字的時候會自動加上版權訊息，這個在辛西亞大大的文章中也有教學，我這邊主要做了一點修改(真的是一點XD)，下面將直接實作。直接在 _includes/_scripts/pages/post-details.html裡面新增document.addEventListener("copy", function (evt) {		let text = document.getSelection().function toString() { [native code] }(); //抓取反白區塊的文字。		if (text.length &gt;= 100) {  //當複製超過一百個字元加上文字。			text = text + "\n\n" + "=========================================\n" + "你複製整段要幹嘛==?";		}        console.log(text)		let clipdata = evt.clipboardData || window.clipboardData;		clipdata.setData("text", text); //將剪貼簿的文字改成剛剛產生的text		evt.preventDefault();	});成果如圖:新增留言區不論是Blogger、CSDN、IT邦等等網誌都有留言區，除了可以讓網友給作者留言另外最重要的就是酷，在爬了一段時間之後決定使用Valine來當本網站的留言系統，選擇Valine的原因是因為：輕量化、好部署、可匿名留言、沒廣告，對，最重要的一點就是沒有廣告！對這方面有興趣的朋友可以看Ivan Mak大大的這篇在 Jekyll 上使用 Valine 作為評論系統/留言版這裡寫得比我詳細太多了，我主要也是參考這篇文章完成留言系統架設的，但人生就像OO充滿皺褶，所以這邊除了部署步驟還要額外紀錄一下我遇到的BUG。Valine 的安裝和配置  Valine 誕生於2017年8月7日，是一款基於LeanCloud的快速、簡潔且高效的無後端評論系統。註冊 leancloud選擇註冊國際版的就好了。AppID跟AppKey進入控制檯點擊左上角創建應用填入應用名稱，選擇開發版即可，然後進到設置/應用憑證找到並記住你的AppID跟AppKey，等等要用。新增各個頁面因為我用的next這個模板沒有內建Valine，所以要自己新增各個頁面。新增valine.htm在 _includes_third-party\comments裡面添加一個文件valine.htm{% unless site.duoshuo_shortname  or site.disqus_shortname  or site.hypercomments_id  or site.gentie_productKey  or site.duoshuo and site.duoshuo.shortname %}{% if site.valine_comment.enable %}&lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt; //我自己是沒有下是這行，因為沒有在*中國境內*會404&lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; //這個我打包下來放在本地&lt;script&gt;    new Valine({        el: '#comments',        app_id: '{{ site.valine_comment.leancloud_appid }}',   //這裡變量的取值在網站配置文件裡_config.yml        app_key: '{{ site.valine_comment.leancloud_appkey }}', //這裡變量的取值在網站配置文件裡_config.yml        placeholder:'{{ site.valine_comment.placeholder }}'    //這裡變量的取值在網站配置文件裡_config.yml,        serverURLs: "your_REST_API網址"    });&lt;/script&gt;{% endif %}{% endunless %}修改_config.yml配置在_config.yml添加變量app_id，app_key， placeholde的值，關於取值傳遞到valine.html，是通過jekyll變量構建。  具體程式碼如下：valine_comment:  enable: true  # app_id  leancloud_appid: your_appid  # app_key  leancloud_appkey: your_appkey  # placeholde  placeholder: "提供您的寶貴意見",  套用valine.html由於前面創建了valine.html，需要jekyll套用這個html才能夠執行這個頁面的程式碼，使評論框顯示在每篇文章的頁面，需要在_includes\_third-party\comments\index.html裡面添加程式碼：{% include _third-party/comments/valine.html %}並在_includes/_partials/comments.html裡面插入程式碼：{% elsif site.valine_comment.enable %} &lt;div id="vcomments"&gt;&lt;/div&gt;大功告成?到這邊重載入一下jekyll看一下文章下面應該就會出現評論框了！你也可以到LeanCloud的數據存儲/結構化數據/Comment看一下有沒有留言進來。Valine 的擴充雖然大致上完成了留言系統的建構，但是仍然有些鑑別度跟安全性上的問題還要解決。另外一點就是回覆留言的通知，這個很酷必須要做！回覆通知我這邊是用Gmail來做SMTP的服務系統，因為今年6月之後Google關閉了不安全性行為也因為把自己的密碼傳到別的網站本身就是一件不好的事，所以我們要申請一個for Valine使用的應用程式密碼。生成APP專用密碼Google 的 App 專用密碼生成網址 : https://myaccount.google.com/apppasswords選取應用程式和選取裝置都可以任意選，只是方便自己記憶這個密碼是用來作什麼用途。我自己選取應用程式是有乖乖選郵件、選取裝置那邊填上Valine之後就會獲得一個16字元的密碼。設定LeanCloud到 雲引擎/WEB/設置/添加新變量            變量      例子      說明                  SITE_NAME      AnkMak Blog	[必須]      網站名稱              SITE_URL      https://ankmak.com	[必須]      網站 URL              SMTP_SERVICE      Gmail	[必須]      SMTP 服務(支援列表)              SMTP_USER      xxx@gmail.com	[必須]      Gmail 郵箱名稱              SMTP_PASS      wnxxxxxxxxxxxxkv	[必須]      剛才產生的 App 密碼              SENDER_NAME      Ank Mak	[必須]      寄件人名稱              SENDER_EMAIL      xxx@xxx.xx	[必須]      寄件人 Email              ADMIN_URL      https://xxx-xxx.avosapps.us	[建議]      自動喚醒服務用(填入剛才創建的雲引擎域名)              BLOGGER_EMAIL      xxx@xxx.xx	[可選]      收件 email，默認為 SENDER_EMAIL              AKISMET_KEY      xxxxxxxx	[可選]      Akismet Key 用於垃圾評論檢測，設為 MANUAL_REVIEW 表示開啟人工審核，留空為不使用      更多參數的說明可以看Github 上 Valine-Admin 文檔: https://github.com/DesertsP/Valine-Admin部署 LeanCloud 雲引擎雲引擎/部署/Git部署/部署Git網址填上 https://github.com/DesertsP/Valine-Admin.git直接按部署就好了。  這邊可以試一下回復留言，應該可以收到信了。評論管理要先註冊管理員用於管理信息，註冊網址為 https://雲引擎域名.avosapps.us/sign-up (可以在部署狀態裡找到)註冊好之後到https://雲引擎域名.avosapps.us/登入就可以管理留言了，我是覺得有點雞肋拉哈哈。定時自動喚醒由於免費版的雲引擎每天最多運行 18 個小時，而且每半個小時會執行休眠策略，在休眠期間會暫停郵件通知服務，所以我們需要啟動 2 項雲函數定時任務來解決休眠時的問題:  自動喚醒 : 每半小時執行一次喚醒以防止休眠(先要創建雲引擎域名)  漏發郵件檢查 : 每天的固定時間檢查過去 24 小時內漏發的郵件並重發以下是我參考AnkMak大大對雲函數的設定:選擇 self-wake 雲函數，Cron 表達式為 0 */30 0-17 * * ?，表示每天 00:00 到 17:59 ，每隔 30 分鐘訪問雲引擎。(由於國際版使用 UTC-0 時間，即每天早上 8 點到 凌晨 01:59，所以最後一次執行為 01:30)選擇 resend-mails 雲函數，Cron 表達式為 0 0 0-16 * * ?，表示每天 00:00 到 16:59 內，每小時一次檢查過去 24 小時內漏發的通知郵件並補發。LeanCloud 流控問題的解決方法  “error”:”因流控原因，通过定时任务唤醒体验版实例失败，建议升级至标准版云引擎实例避免休眠 https://url.leanapp.cn/dwAEksv”由於官方有流量控制的問題，所以 LeanCloud 內建的定時任務只適用於當天，隔天早上起床後就會在日誌裡出現定時任務喚醒體驗版實例失敗的訊息:解決思路：  只要當天登入過一次評論管理系統，定時任務裡的自動喚醒又會正常運作，但流控問題隔天又會發生。所以這種方法就需要每天早上手動的登錄雲引擎的後台，用來激活容器。所以我是使用Google的AppScript寫一個腳本每30分鐘訪問一次管理介面，使用方法如下：新增AppScript專案點選新專案並新增這段程式碼：function doResponse() {  const now_hour = new Date().getHours(); //獲取現在的時間(小時)    if(now_hour &gt;= 8 || now_hour &lt;= 2)  //(凌晨2~8點不執行)  {      var response = UrlFetchApp.fetch('https://weichang.avosapps.us'); //訪問後台登入頁      Logger.log(response.getContentText());  }}然後部署/新增部署作業點旁邊鬧鐘的圖案新增觸發條件：這樣就會每半小時自動訪問一次評論管理系統了!必填欄位設定由於新增了郵件的通知功能，如果留言時不提供郵箱的話就沒用了，因此我把 NickName 和 Email 都設定為必要選項。到 _includes\_third-party\comments\valine.htm  (每個人的目錄位置可能不同)在括號行內加入 requiredFields: ['nick','mail']new Valine({          el: '#comments',          app_id: 'JKnSyYYosilnYSK5qqBw9Ewd-MdYXbMMI',             app_key: 'nsxgeLYfEW1x8CBRdAzBbIsU',           placeholder:'提供您的寶貴意見。',             serverURLs: 'https://jknsyyyo.api.lncldglobal.com',          requiredFields: ['nick','mail'],          verify: true      });自訂文字一樣到到 _includes\_third-party\comments\valine.htm&lt;script&gt;	var langName = "tw",		langMode = {			nick: "NickName(必填)",			mail: "E-Mail(必填)",			link: "Website(http://)",			nickFail: "NickName cannot be less than 3 bytes.",			mailFail: "Please confirm your email address.",			sofa: "No comment yet.",			submit: "Submit",			reply: "Reply",			cancelReply: "Cancel reply",			comments: "Comments",			cancel: "Cancel",			confirm: "Confirm",			continue: "Continue",			more: "Load More...",			preview: "Preview",			emoji: "Emoji",			expand: "See more....",			seconds: "seconds ago",			minutes: "minutes ago",			hours: "hours ago",			days: "days ago",			now: "just now",			uploading: "Uploading ...",			uploadDone: "Upload completed!",			busy: "Submit is busy, please wait...",			"code-98": "Valine initialization failed, please check your version of av-min.js.",			"code-99": "Valine initialization failed, Please check the `el` element in the init method.",			"code-100": "Valine initialization failed, Please check your appId and appKey.",			"code-140": "The total number of API calls today has exceeded the development version limit.",			"code-401": "Unauthorized operation, Please check your appId and appKey.",			"code-403": "Access denied by API domain white list, Please check your security domain.",		};	new Valine({		el: "#comments",		app_id: "JKnSyYYosilnYSK5qqBw9Ewd-MdYXbMMI",		app_key: "nsxgeLYfEW1x8CBRdAzBbIsU",		placeholder: "提供您的寶貴意見。",		serverURLs: "https://jknsyyyo.api.lncldglobal.com",		requiredFields: ["nick", "mail"],		lang: langName,		langMode: langMode,		verify: true,	});&lt;/script&gt;因為我覺得英文也滿好看的所以就沒改了，這邊langName不能跟預設zh-CN、zh-TW、en、ja的一樣。官方文檔：https://valine.js.org/i18n.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80效果如圖：頭像設定Valine 目前是使用 Gravatar 作為留言板的頭像到 Gravatar 官網註冊一個帳號並設定頭像，請確定自己註冊時所使用的郵箱，評論時填寫一樣的郵箱便會顯示頭像。其他用戶的頭像沒有自定義的郵箱，有以下 7 種默認值可選:            參數值      頭像      說明                  空字符串’’            Gravatar 官方圖形              mp            神秘人(一個灰白頭像)              identicon      、      抽象幾何圖形(根據郵箱生成)              monsterid      、      小怪物(根據郵箱生成)              wavatar      、      用不同面孔和背景組合生成的頭像(根據郵箱生成)              retro      、      八位像素復古頭像(根據郵箱生成)              robohash            一種具有不同顏色、面部等的機器人(根據郵箱生成)              hide             不顯示頭像      根據個人喜好選擇，這裡我自己選擇了 retro 小怪物作為其他用戶的頭像。一樣到到 _includes\_third-party\comments\valine.htm在括號行內加入 avatar: 'retro'new Valine({		el: "#comments",		app_id: "JKnSyYYosilnYSK5qqBw9Ewd-MdYXbMMI",		app_key: "nsxgeLYfEW1x8CBRdAzBbIsU",		placeholder: "提供您的寶貴意見。",		serverURLs: "https://jknsyyyo.api.lncldglobal.com",		requiredFields: ["nick", "mail"],		lang: langName,		langMode: langMode,		verify: true,        avatar: 'retro',	});效果如下：垃圾評論檢測  Akismet (Automattic Kismet)是應用廣泛的一個垃圾留言過濾系統，其作者是大名鼎鼎的WordPress 創始人 Matt Mullenweg，Akismet也是WordPress默認安裝的插件，其使用非常廣泛，設計目標便是幫助博客網站來過濾留言Spam。有了Akismet之後，基本上不用擔心垃圾留言的煩惱了。啟用Akismet後，當博客再收到留言會自動將其提交到Akismet並與Akismet上的黑名單進行比對，如果名列該黑名單中，則該條留言會被標記為垃圾評論且不會發布。先到 akismet 官網(https://akismet.com/development/)註冊一個帳號，這裡我##### 選擇用 Gravatar 的帳號登入選擇 Developers Plan取得 AKISMET API KEY把 AKISMET API KEY 填入到 leancloud 的 AKISMET_KEY 參數裡重啟部署自定义邮件模板            變量      範本      說明                  MAIL_SUBJECT      ${PARENT_NICK}，您在 ${SITE_NAME} 上的評論收到了回覆	[可選]      @回覆時郵件標題              MAIL_TEMPLATE      見下文	[可選]      @回覆時郵件內容              MAIL_SUBJECT_ADMIN      ${SITE_NAME} 上有新評論了	[可選]      博主通知時的郵件標題              MAIL_TEMPLATE_ADMIN      見下文	[可選]      博主通知時郵件內容      郵件通知分成了兩種:  通知博主  被@通知通知博主&lt;div style="border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;"&gt;&lt;h2 style="border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;"&gt;您在&lt;a style="text-decoration:none;color: #12ADDB;" href="${SITE_URL}" target="_blank"&gt;${SITE_NAME}&lt;/a&gt;上的文章有了新的评论&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;${NICK}&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style="background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;"&gt; ${COMMENT}&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style="text-decoration:none; color:#12addb" href="${POST_URL}" target="_blank"&gt;查看回复的完整內容&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;被@通知 的默認範本&lt;div style="border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;"&gt;&lt;h2 style="border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;"&gt;您在&lt;a style="text-decoration:none;color: #12ADDB;" href="${SITE_URL}" target="_blank"&gt;            ${SITE_NAME}&lt;/a&gt;上的评论有了新的回复&lt;/h2&gt; ${PARENT_NICK} 同学，您曾发表评论：&lt;div style="padding:0 12px 0 12px;margin-top:18px"&gt;&lt;div style="background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;"&gt;            ${PARENT_COMMENT}&lt;/div&gt;&lt;p&gt;&lt;strong&gt;${NICK}&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style="background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;"&gt; ${COMMENT}&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style="text-decoration:none; color:#12addb" href="${POST_URL}" target="_blank"&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style="text-decoration:none; color:#12addb" href="${SITE_URL}" target="_blank"&gt;${SITE_NAME}&lt;/a&gt;。&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;注意，下列變數僅用於郵件範本裡的 HTML 變數中，請勿與雲引擎環境變數混淆            範本裡的變數      說明                  SITE_NAME      網站名稱              SITE_URL      網站 URL              POST_URL      文章 URL (完整路徑)              PARENT_NICK      收件人名稱 (被@者、父級評論人)              PARENT_COMMENT      父級評論內容              NICK      新評論者名稱              COMMENT      新評論內容      我只有把簡體換成繁體而已，我也有把專案fork下來把系統內的部分文字改成繁體的，下面這是我改的版本Git:https://github.com/zwei-c/Valine-Admin效果如圖:瀏覽人數在網站上顯示瀏覽人數是以前玩無名小站覺得很酷的功能，雖然會越用越心寒==我是使用 不蒜子 這個js套件：  顯示站點總訪問量&lt;span id="busuanzi_container_site_pv"&gt;    本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;  顯示單頁面訪問量&lt;span id="busuanzi_container_page_pv"&gt;  本文总阅读量&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次&lt;/span&gt;用在jekyll的方法：我是放在側邊攔所以直接到 _includes/_custom/sidebar.html(不同模板位置可能不同)新增&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;本站總訪問量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次. &lt;br&gt;本站總訪問人數&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;位. &lt;br&gt;本頁面訪問次數&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次.效果如圖:結論jekyll這部分的功能更新應該暫時告一段落，先記錄一下待完成(這次搞不定的東西)的項目：  Appscript沒辦法設定某個時段不跑，這樣會導致某些時間會出現流控問題。  文章區分享按鈕  訂閱按鈕  待補充…再來要感謝辛西亞大大、AnkMar大大提供思路跟很完整的實作經驗，其實本篇文章寫的內容基本上都是兩位大大的經驗，我只是將我本身的實作過程記錄下來並加上一些我在實作過程中遇到的bug解決方法，老實說架設網站不難，但是寫網誌真的好難。看起來只要把步驟貼到文章上面就好了，但實際在寫的時候發現有時一些參數或函數、工具的用法說明，說明文件或是前人的文章已經寫得夠好了，搞得我只能把別人的東西Copy&amp;Paste到自己的文章上，有點怪不好意思的。參考資料  在 Jekyll 上使用 Valine 作為評論系統/留言版  Valine Admin 配置教學 - 設定 Valine 作為評論區/留言版並透過 Email 取得留言通知  不蒜子  Valine  Valine-Admin  【種樹】新增版權訊息  【種樹】複製網頁文字時，加上網站的作者與網址  所有关于Valine评论系统的配置都在这里【合集】  Hexo博客进阶：为Next主题添加Valine评论系统]]></content>
      <categories>
        
          <category> 前端 </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
          <tag> Valine </tag>
        
          <tag> App Script </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[建置jekyll+Github Page]]></title>
      <url>/%E5%89%8D%E7%AB%AF/2022/07/04/001-build/</url>
      <content type="text"><![CDATA[前言原本想在將自己遇到的問題或一些程式、讀書心得寫在Blogger裡面，但都要去web上面寫文章。第一不夠酷，第二則覺得有點麻煩。所以藉著有GitHub pages這個service可以用的機會將做一個個人網站這個放在心裡很久的想法實現。使用的工具  GitHub pages  Jekyll  PowerShell  VSCode環境  Windows 10GitHub pages其實我本身寫的code跟上班寫的code都是放在GitLab上，但當我看到GitLab pages的時候已經把這個網站架好了所以沒什麼意外的話應該會繼續使用GitHub pages來當我的個人web site。關於GitHub pages其實網路上的教學很多而且都寫得很清楚，所以除了基本的作業流程另外補充一下我自己遇到的問題。initialization  需要的東西          GitHub帳號        新增名為「username.github.io」的專案，這個 username 指的是自己的 GitHub 帳號。這不僅是你的專案名稱，也是你的 blog 網址。專案成立後，按照 Quick setup 的提示準備好專案的資料夾。  Clone下來到本地資料夾，這邊可以先照著GitHub pages 上面的教學create一個index.html然後推上去連接到自己的網站上面看看效果 :)  提交之後要過兩三分鐘才會顯示出來，所以不要緊張到這邊之後GitHub pages基本已經建置完成。如果你有匠人精神可以直接在這邊手刻CSS跟HTML來做網頁，但小弟不才又懶所以接著要使用Jekyll來繼續佈置網站。JekyllJekyll 是 Ruby 所編寫出來的 framework，因此在安裝 Jekyll 之前要先安裝Ruby。基本安裝https://rubyinstaller.org/我是選擇當前最新版本Ruby+Devkit 3.1.2-1 (x64)來進行安裝根據Jekyll官方文件所述，要使用WITH DEVKIT的版本來裝。之前沒有仔細看文件直接裝了WITHOUT DEVKIT版本導致後面在裝MINGGW的時候出現一堆error = =安裝完成之後直接勾選  Run 'ridk install' to set up MSYS2 ...。接著會自動在terminal開啟ruby安裝的介面，這邊他已經幫你key in好選項 1 3直接按enter來安裝就好了看到 Install MSYS2 and MINGW development toolchain succeeded就代表安裝好了!再來在執行gem install jekyll bundler接下來將專案（e.g. myblog 資料夾）設為 Jekyll 的網站，由於我的專案中已經存在些檔案，所以我在指令的後面加上 force 避免覆蓋。網站設置完時，它會動配置一組預設主題 - minima。jekyll new myblog  --force 到此網站就算建立完成了，若想在上線前預覽建置的結果，可先進入專案進行編譯。cd myblogjekyll serve編譯結果可在瀏覽器輸入 http://localhost:4000 後查看。若可以順利執行，就將這次的 diff 進行 commit 後送上 github了。在這邊我遇到一個BUGcannot load such file -- webrick (LoadError)根據官方的項目的說明：這是因為：從 Ruby 3.0 開始 webrick 已經不在綁定到 Ruby 中了，webrick 需要手動進行添加。添加的指令為：bundle add webrickbundle install後就可以解決這個問題了。主題更換挑選主題網路上搜尋jekyll theme就有很多網站供應jekyll的模板了，我是使用jekyll-theme-next- demo這個主題，照著他的步驟：git clone https://github.com/Simpleyyt/jekyll-theme-next.git我自己是把jekyll-theme-next這個資料夾內除了.git相關的檔案移到剛剛建立的my-blog資料夾內，並刪除Gemfile.lock後執行bundle install在runbundle exec jekyll server這個時候用瀏覽器訪問localhost:4000就可以看到但是看terminal上面會有GitHub Metadata: No GitHub API authentication could be found這個報錯，原因很複雜可以自己去估狗一下XD。有個簡單的方法可以解決，到_config.yml中找到description給他填上值就OK了!撰寫文章終於把環境弄好了，接著可以看該模板內的_posts這個資料夾內的MD檔，把MD檔丟進去jekyll就會把它變成html然後顯示到你的網站上面了，只是要注意MD檔的格式一定要是YYYY-MM-DD-name.md並且MD檔的開頭必須是：---title: 文章標題date: 2022-07-04categories:- 他可以tags:- 穿過- 我的- 巴巴--- // 以下開始撰寫你的文章根據我參考的這篇作者表示，不同的模板可能有不同的規範，這部分如果使用不同模板的同學自己留意一下。總結整個網站包含查資料跟寫這篇文章的時間大概花了4-5小時，但真正build網站大概只花了30分鐘，使用GitHub pages跟jekyll來建置個人網站真的很快又很簡單XD，希望之後有毅力能持續的更新這個網站!參考資料  辛西亞的技能樹- 【種樹】使用 Jekyll 和搭建 Github Pages  NexT使用文檔  GitHub Pages  Jekyll 运行的时候提示错误 cannot load such file – webrick (LoadError)  jekyll官方文檔  見字如畫 - githubPages+jekyll搭建博客和使用jekyll模板  搭建msys2基礎開發平台]]></content>
      <categories>
        
          <category> 前端 </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
          <tag> github </tag>
        
          <tag> ruby </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
